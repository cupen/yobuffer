// Packagerpc is generated by yobuffer@0.1.0
package rpc

import (
	"fmt"
	"reflect"

	"github.com/cupen/yobuffer/encodings/tiny"
)

var (
	structs map[int]reflect.Type
)

func init() {
	structs = map[int]reflect.Type{
		0: reflect.TypeOf(&void{}),
	
		10001: reflect.TypeOf(&PlayerInfo{}),
	
		10003: reflect.TypeOf(&PlayerID{}),
	}
}

// external struct PlayerInfo with id 10002
type ExternalStructPlayerInfo PlayerInfo



// void 
type void struct {
	
}

func (t *void) Size() (size int) {
	return
}

func (t *void) Marshal() ([]byte, error) {
	dAtA := make([]byte, t.Size())
	return dAtA, nil
}

func (t *void) Unmarshal(dAtA []byte) error {
	return nil
}
// PlayerInfo "玩家信息"
type PlayerInfo struct {
	UserId string `yobuffer:"1"`
	Name string `yobuffer:"2"`
	Avatar string `yobuffer:"3"`
	ShortId int64 `yobuffer:"4"`
	Level int16 `yobuffer:"5"`
	WinRate float64 `yobuffer:"6"`
	IsAdmin bool `yobuffer:"7"`
	
}

func (t *PlayerInfo) Size() (size int) {
	size += 4 + len(t.UserId) // UserId<string>

	size += 4 + len(t.Name) // Name<string>

	size += 4 + len(t.Avatar) // Avatar<string>

	size += 8 // ShortId<int64>

	size += 2 // Level<int16>

	size += 8 // WinRate<float64>

	size += 1 // IsAdmin<bool>

	return
}

func (t *PlayerInfo) Marshal() ([]byte, error) {
	dAtA := make([]byte, t.Size()) 
	enc := tiny.GetEncoder()
	i := 0
	// UserId<string>
	enc.String(dAtA[i:], t.UserId)
	i += 4+len(t.UserId)
	
	// Name<string>
	enc.String(dAtA[i:], t.Name)
	i += 4+len(t.Name)
	
	// Avatar<string>
	enc.String(dAtA[i:], t.Avatar)
	i += 4+len(t.Avatar)
	
	// ShortId<int64>
	enc.Int64(dAtA[i:], t.ShortId)
	i += 8
	
	// Level<int16>
	enc.Int16(dAtA[i:], t.Level)
	i += 2
	
	// WinRate<float64>
	enc.Float64(dAtA[i:], t.WinRate)
	i += 8
	
	// IsAdmin<bool>
	enc.Bool(dAtA[i:], t.IsAdmin)
	i += 1
	
	if i != len(dAtA) {
		return nil, fmt.Errorf("invalid data size. expected:%d  actual:%d", len(dAtA), i)
	}

	return dAtA, nil
}

func (t *PlayerInfo) Unmarshal(dAtA []byte) error { 
	dec := tiny.GetDecoder()
	i := 0
	// UserId<string>
	t.UserId = dec.String(dAtA[i:])
	i += 4+len(t.UserId)
	
	// Name<string>
	t.Name = dec.String(dAtA[i:])
	i += 4+len(t.Name)
	
	// Avatar<string>
	t.Avatar = dec.String(dAtA[i:])
	i += 4+len(t.Avatar)
	
	// ShortId<int64>
	t.ShortId = dec.Int64(dAtA[i:])
	i += 8
	
	// Level<int16>
	t.Level = dec.Int16(dAtA[i:])
	i += 2
	
	// WinRate<float64>
	t.WinRate = dec.Float64(dAtA[i:])
	i += 8
	
	// IsAdmin<bool>
	t.IsAdmin = dec.Bool(dAtA[i:])
	i += 1
	
	return nil
}
// PlayerID "作为RPC参数"
type PlayerID struct {
	UserId string `yobuffer:"1"`
	
}

func (t *PlayerID) Size() (size int) {
	size += 4 + len(t.UserId) // UserId<string>

	return
}

func (t *PlayerID) Marshal() ([]byte, error) {
	dAtA := make([]byte, t.Size()) 
	enc := tiny.GetEncoder()
	i := 0
	// UserId<string>
	enc.String(dAtA[i:], t.UserId)
	i += 4+len(t.UserId)
	
	if i != len(dAtA) {
		return nil, fmt.Errorf("invalid data size. expected:%d  actual:%d", len(dAtA), i)
	}

	return dAtA, nil
}

func (t *PlayerID) Unmarshal(dAtA []byte) error { 
	dec := tiny.GetDecoder()
	i := 0
	// UserId<string>
	t.UserId = dec.String(dAtA[i:])
	i += 4+len(t.UserId)
	
	return nil
}




// ==================
//     Define RPC 
// ==================
// RpcAPI ...
type RpcAPI interface {
	// "获取玩家信息"
	// () 
	GetPlayerInfo()(*PlayerInfo, error)
	
	// "获取玩家信息"
	// (id PlayerID,) 
	GetOtherPlayerInfo(*PlayerID)(*PlayerInfo, error)
	
	// "发送聊天信息"
	// (id PlayerID,) 
	SendChatMessage(*PlayerID)(*void, error)
	
}

func NewRpcSession(instance RpcAPI) *RpcSession {
	return &RpcSession {
		instance: instance,
	}
}

type RpcSession struct {
	instance RpcAPI
}

// OnCall ...
func (s *RpcSession) OnCall(methodId uint16, args []byte) ([]byte, error) {
	api := s.instance
	if api == nil {
		return nil, fmt.Errorf("missing RPC instance")
	}

	switch methodId {
	case 20001:
		resp, err := api.GetPlayerInfo()
		if err != nil {
			return nil, err
		}
		return resp.Marshal()

	case 20002:
		msg := PlayerID{}
		if err := msg.Unmarshal(args); err != nil {
			return nil, err
		}
		resp, err := api.GetOtherPlayerInfo(&msg)

		if err != nil {
			return nil, err
		}
		return resp.Marshal()

	case 20003:
		msg := PlayerID{}
		if err := msg.Unmarshal(args); err != nil {
			return nil, err
		}
		resp, err := api.SendChatMessage(&msg)

		if err != nil {
			return nil, err
		}
		return resp.Marshal()

	default:
		return nil, fmt.Errorf("missing method id:%d args:%v", methodId, args)
	}
}

// OnSend ...
func (s *RpcSession) OnSend(methodId uint16, args []byte) error {
	return nil
}
