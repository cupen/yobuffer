package languages

const Go = `// Package{{.Package}} is generated by yobuffer@0.1.0
package {{.Package}}

import (
	"fmt"
	"reflect"

	"github.com/cupen/yobuffer/encodings/tiny"
)

var (
	structs map[int]reflect.Type
	tinyEncoder = tiny.NewEncoder()
	tinyDecoder = tiny.NewDecoder()
)

func init() {
	structs = map[int]reflect.Type{
	{{- range $k, $ := .Structs }}
		{{ $.ID}}: reflect.TypeOf(&{{ $.Name }}{}),
	{{ end -}}
	}
}

{{ range $es := .GetExternalStructs -}}
// external struct {{ $es.Name }} with id {{ $es.ID }}
type ExternalStruct{{ $es.Name }} {{ $es.Name }}
{{ end }}


{{ range $_, $ := .Structs -}}
// {{ $.Name }} {{ $.Desc }}
type {{ $.Name }} struct {
	{{ range $f := $.Fields -}}
	{{$f.Name}} {{$f.Type}} ` + "`" + `yobuffer:"{{ $f.Offset }}"` + "`" + `
	{{ end }}
}

func (t *{{$.Name}}) Size() (size int) {
{{- range $f := $.Fields -}}
	{{- if (gt $f.GetSizeFixed 0) }}
	size += {{fieldSizeOf $f.Type }} // {{$f.Name}}<{{$f.Type}}>

	{{- else if (eq $f.Type "string") }}
	size += 4 + len(t.{{$f.Name}}) // {{$f.Name}}<{{$f.Type}}>

	{{- else -}}
	{{panic $f.Type}}
	{{ end }}
{{ end }}
	return
}

func (t *{{$.Name}}) Marshal() ([]byte, error) {
	enc := tiny.GetEncoder()
	dAtA := make([]byte, t.Size())
	i := 0
{{- range $f := $.Fields }}
	{{- $fieldSize := $f.GetSizeFixed }}
	// {{$f.Name}}<{{$f.Type}}>
	{{- if (eq $f.Type "int8") }}
	enc.Int8(dAtA[i:], t.{{$f.Name}})
	i += {{ $fieldSize }} 

	{{- else if (eq $f.Type "int16") }}
	enc.Int16(dAtA[i:], t.{{$f.Name}})
	i += {{ $fieldSize }} 

	{{- else if (eq $f.Type "int32") }}
	enc.Int32(dAtA[i:], t.{{$f.Name}})
	i += {{ $fieldSize }} 

	{{- else if (eq $f.Type "int64") }}
	enc.Int64(dAtA[i:], t.{{$f.Name}})
	i += {{ $fieldSize }} 

	{{- else if (eq $f.Type "uint8") }}
	enc.UInt8(dAtA[i:], t.{{$f.Name}})
	i += {{ $fieldSize }} 

	{{- else if (eq $f.Type "uint16") }}
	enc.UInt16(dAtA[i:], t.{{$f.Name}})
	i += {{ $fieldSize }} 

	{{- else if (eq $f.Type "uint32") }}
	enc.UInt32(dAtA[i:], t.{{$f.Name}})
	i += {{ $fieldSize }} 

	{{- else if (eq $f.Type "uint64") }}
	enc.UInt64(dAtA[i:], t.{{$f.Name}})
	i += {{ $fieldSize }} 

	{{- else if (eq $f.Type "float32") }}
	enc.Float32(dAtA[i:], t.{{$f.Name}})
	i += {{ $fieldSize }} 

	{{- else if (eq $f.Type "float64") }}
	enc.Float64(dAtA[i:], t.{{$f.Name}})
	i += {{ $fieldSize }} 

	{{- else if (eq $f.Type "bool") }}
	enc.Bool(dAtA[i:], t.{{$f.Name}})
	i += {{ $fieldSize }} 

	{{- else if (eq $f.Type "string") }}
	enc.String(dAtA[i:], t.{{$f.Name}})
	i += 4+len(t.{{$f.Name}})

	{{- else }}
	{{ panic $f.Type }}

	{{- end }}
{{ end }}
	if i != len(dAtA) {
		return nil, fmt.Errorf("invalid data size. expected:%d  actual:%d", len(dAtA), i)
	}
	return dAtA, nil
}

func (t *{{$.Name}}) Unmarshal(dAtA []byte) error {
	dec := tiny.GetDecoder()
	i := 0
	_ = i
{{- range $f := $.Fields }}
	// {{$f.Name}}<{{$f.Type}}>
	{{- $fieldSize := $f.GetSizeFixed }}
	{{- if (eq $f.Type "int8") }}
	t.{{$f.Name}} = dec.Int8(dAtA[i:])
	i += {{ $fieldSize }} 

	{{- else if (eq $f.Type "int16") }}
	t.{{$f.Name}} = dec.Int16(dAtA[i:])
	i += {{ $fieldSize }} 

	{{- else if (eq $f.Type "int32") }}
	t.{{$f.Name}} = dec.Int32(dAtA[i:])
	i += {{ $fieldSize }} 

	{{- else if (eq $f.Type "int64") }}
	t.{{$f.Name}} = dec.Int64(dAtA[i:])
	i += {{ $fieldSize }} 

	{{- else if (eq $f.Type "uint8") }}
	t.{{$f.Name}} = dec.UInt8(dAtA[i:])
	i += {{ $fieldSize }} 

	{{- else if (eq $f.Type "uint16") }}
	t.{{$f.Name}} = dec.UInt16(dAtA[i:])
	i += {{ $fieldSize }} 

	{{- else if (eq $f.Type "uint32") }}
	t.{{$f.Name}} = dec.UInt32(dAtA[i:])
	i += {{ $fieldSize }} 

	{{- else if (eq $f.Type "uint64") }}
	t.{{$f.Name}} = dec.UInt64(dAtA[i:])
	i += {{ $fieldSize }} 

	{{- else if (eq $f.Type "float32") }}
	t.{{$f.Name}} = dec.Float32(dAtA[i:])
	i += {{ $fieldSize }} 

	{{- else if (eq $f.Type "float64") }}
	t.{{$f.Name}} = dec.Float64(dAtA[i:])
	i += {{ $fieldSize }} 

	{{- else if (eq $f.Type "bool") }}
	t.{{$f.Name}} = dec.Bool(dAtA[i:])
	i += {{ $fieldSize }} 

	{{- else if (eq $f.Type "string") }}
	t.{{$f.Name}} = dec.String(dAtA[i:])
	i += 4+len(t.{{$f.Name}})

	{{- else }}
	{{ panic $f.Type }}

	{{- end }}
{{ end }}
	return nil

}
{{ end -}}

{{ $pkgname := title .Package }}
{{ $RPCInterface := (print $pkgname  "API") }}
{{ $RPCStruct := (print $pkgname "Session") }}

// ==================
//     Define RPC 
// ==================
{{ define "ReturnType" -}}
	{{- if .HasReturn -}}
		error
	{{- else -}}
		({{ .Return  }}, error)
	{{- end -}}
{{- end -}}


{{ define "byte2object" -}}
	{{- if $.HasArg -}}
		_arg := {{ $.Arg.Name }}{}
		err := _arg.Unmarshal(arg)
	{{- else -}}
		({{ $.Return }}, error)
	{{- end -}}
{{- end -}}



// {{$RPCInterface}} ...
type {{$RPCInterface}} interface {
{{- range $ := .GetRPCList }}
	// {{ $.Desc }}
	// (
		{{- range $arg := $.Args -}}
		{{$arg.Name}} {{$arg.Type}},
		{{- end -}}
	) 
	{{$.Name}}(
		{{- if $.HasArg -}}
		*{{ $.Arg.Type }}
		{{- end -}}
	) 
		{{- if $.HasReturn -}}
		(*{{ $.Return }}, error)
		{{- else -}}
		{{print " error" }}
		{{- end }}
	{{ end }}
}

func New{{ $RPCStruct }}(instance {{ $RPCInterface }}) *{{ $RPCStruct }} {
	return &{{ $RPCStruct }} {
		instance: instance,
	}
}

type {{ $RPCStruct }} struct {
	instance {{ $RPCInterface }}
}

// OnCall ...
func (s *{{ $RPCStruct }}) OnCall(methodId uint16, args []byte) ([]byte, error) {
	api := s.instance
	if api == nil {
		return nil, fmt.Errorf("missing RPC instance")
	}

	switch methodId {
{{- range $ := .GetRPCList }}
	case {{ $.ID }}:
		{{ if $.HasArg -}}
		msg := {{$.Arg.Type}}{}
		if err := msg.Unmarshal(args); err != nil {
			return nil, err
		}
		resp, err := api.{{$.Name}}(&msg)

		{{ else -}}
		resp, err := api.{{$.Name}}()
		{{ end -}}
		if err != nil {
			return nil, err
		}
		return resp.Marshal()
{{ end }}
	default:
		return nil, fmt.Errorf("missing method id:%d args:%v", methodId, args)
	}
}

// OnSend ...
func (s *{{ $RPCStruct }}) OnSend(methodId uint16, args []byte) error {
	return nil
}
`
